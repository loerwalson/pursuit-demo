<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>追击对比模拟（数值输入版：B1/B2 + 共用距离图 + 惯性/延迟 + 捕获暂停）</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; }
    .row { display: grid; grid-template-columns: 520px 1fr; gap: 16px; align-items: start; }
    .panel { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    .panel h2 { font-size: 16px; margin: 0 0 10px; }
    .sectionTitle { font-size: 13px; margin-top: 12px; font-weight: 700; }
    label { display: block; font-size: 12px; margin: 10px 0 4px; color: #333; }
    select, input[type="number"] { width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 10px; }
    input[type="number"] { appearance: textfield; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .btns { display:flex; gap: 10px; margin-top: 12px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:hover { background: #f6f6f6; }
    .canv { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    canvas { width: 100%; height: 520px; border: 1px solid #ddd; border-radius: 12px; background: #fff; }
    .note { background:#fafafa; border:1px dashed #ddd; border-radius:10px; padding:10px; margin-top:10px; font-size:12px; color:#555; line-height:1.45; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <div class="row">
    <div class="panel">
      <h2>控制面板（A=目标，B1/B2=追击者对比，全部数值输入）</h2>

      <div class="sectionTitle">全局</div>
      <div class="grid2">
        <div>
          <label>A 点运动方式</label>
          <select id="trajA">
            <option value="ellipse" selected>椭圆 (Ellipse)</option>
            <option value="circle">圆 (Circle)</option>
            <option value="lissajous">李萨如 (Lissajous)</option>
            <option value="line">直线往返 (Line)</option>
            <option value="randomwalk">随机游走 (Random Walk)</option>
          </select>
        </div>
        <div>
          <label>时间倍率（>1 更快）</label>
          <input id="speedMul" type="number" value="1.2" step="0.1" min="0.1" />
        </div>
      </div>

      <div class="grid2">
        <div>
          <label>A 速度（px/s）</label>
          <input id="aSpeed" type="number" value="160" step="10" min="0" />
        </div>
        <div>
          <label>随机游走强度（A=randomwalk 才生效）</label>
          <input id="rw" type="number" value="2.5" step="0.1" min="0" />
        </div>
      </div>

      <div class="grid2">
        <div>
          <label>捕获半径（px，默认 0.5）</label>
          <input id="captureR" type="number" value="0.5" step="0.1" min="0" />
        </div>
        <div>
          <label>尾迹长度（点数）</label>
          <input id="trailLen" type="number" value="220" step="10" min="0" />
        </div>
      </div>

      <div class="grid2">
        <div>
          <label>距离图窗口长度（秒）</label>
          <input id="plotWindow" type="number" value="12" step="1" min="2" />
        </div>
        <div>
          <label>积分步长上限 dtMax（秒）</label>
          <input id="dtMax" type="number" value="0.05" step="0.01" min="0.01" />
        </div>
      </div>

      <div class="sectionTitle">B1（橙）</div>
      <div class="grid3">
        <div>
          <label>策略</label>
          <select id="b1Rule">
            <option value="pure">Pure（追当前位置）</option>
            <option value="lead" selected>Lead（提前量）</option>
            <option value="pn">PN（简化比例导引）</option>
          </select>
        </div>
        <div>
          <label>速度（px/s）</label>
          <input id="b1Speed" type="number" value="170" step="10" min="0" />
        </div>
        <div>
          <label>基础转向（rad/s）</label>
          <input id="b1Turn" type="number" value="4" step="0.5" min="0" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>质量/惯性 m（越大越难转）</label>
          <input id="b1Mass" type="number" value="2.0" step="0.1" min="0.1" />
        </div>
        <div>
          <label>反应延迟 τ（秒）</label>
          <input id="b1Delay" type="number" value="0.30" step="0.05" min="0" />
        </div>
      </div>

      <div class="sectionTitle">B2（紫）</div>
      <div class="grid3">
        <div>
          <label>策略</label>
          <select id="b2Rule">
            <option value="pure" selected>Pure（追当前位置）</option>
            <option value="lead">Lead（提前量）</option>
            <option value="pn">PN（简化比例导引）</option>
          </select>
        </div>
        <div>
          <label>速度（px/s）</label>
          <input id="b2Speed" type="number" value="170" step="10" min="0" />
        </div>
        <div>
          <label>基础转向（rad/s）</label>
          <input id="b2Turn" type="number" value="4" step="0.5" min="0" />
        </div>
      </div>
      <div class="grid2">
        <div>
          <label>质量/惯性 m</label>
          <input id="b2Mass" type="number" value="3.5" step="0.1" min="0.1" />
        </div>
        <div>
          <label>反应延迟 τ（秒）</label>
          <input id="b2Delay" type="number" value="0.60" step="0.05" min="0" />
        </div>
      </div>

      <div class="btns">
        <button id="toggle">暂停</button>
        <button id="reset">重置</button>
      </div>

      <div class="note">
        左图：A（蓝）、B1（橙）、B2（紫）。右图：同一张图画 <span class="mono">d1(t)</span> 与 <span class="mono">d2(t)</span>。<br/>
        捕获：当任一 <span class="mono">d ≤ 捕获半径</span>，自动暂停并标注先捕获者。
      </div>
    </div>

    <div class="canv">
      <div>
        <div style="font-size:12px;color:#555;margin:0 0 6px 4px;">轨迹与两点距离（平面）</div>
        <canvas id="scene" width="720" height="520"></canvas>
      </div>
      <div>
        <div style="font-size:12px;color:#555;margin:0 0 6px 4px;">距离-时间曲线（同图对比）</div>
        <canvas id="plot" width="720" height="520"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // canvases
  const scene = document.getElementById('scene');
  const plot  = document.getElementById('plot');
  const ctx   = scene.getContext('2d');
  const pctx  = plot.getContext('2d');
  const W = scene.width, H = scene.height;
  const PW = plot.width,  PH = plot.height;
  const center = { x: W/2, y: H/2 };
  const scale = Math.min(W,H) * 0.35;

  // inputs
  const trajAEl     = document.getElementById('trajA');
  const speedMulEl  = document.getElementById('speedMul');
  const aSpeedEl    = document.getElementById('aSpeed');
  const rwEl        = document.getElementById('rw');
  const captureREl  = document.getElementById('captureR');
  const trailLenEl  = document.getElementById('trailLen');
  const plotWinEl   = document.getElementById('plotWindow');
  const dtMaxEl     = document.getElementById('dtMax');

  const b1RuleEl  = document.getElementById('b1Rule');
  const b1SpeedEl = document.getElementById('b1Speed');
  const b1TurnEl  = document.getElementById('b1Turn');
  const b1MassEl  = document.getElementById('b1Mass');
  const b1DelayEl = document.getElementById('b1Delay');

  const b2RuleEl  = document.getElementById('b2Rule');
  const b2SpeedEl = document.getElementById('b2Speed');
  const b2TurnEl  = document.getElementById('b2Turn');
  const b2MassEl  = document.getElementById('b2Mass');
  const b2DelayEl = document.getElementById('b2Delay');

  const toggleBtn = document.getElementById('toggle');
  const resetBtn  = document.getElementById('reset');

  // state
  let running = true;
  let capturedBy = ""; // "B1" or "B2"
  let t = 0;
  let last = performance.now();

  // A random walk state (if used)
  let rwStateA = { x: center.x + 0.2*scale, y: center.y, vx: 0, vy: 0 };

  // A physical-ish state (moves toward a guide with speed limit)
  let AState = { x: center.x, y: center.y, vx: 0, vy: 0, ax: 0, ay: 0 };

  // pursuers
  let b1 = { x: center.x - 0.25*scale, y: center.y, vx: 160, vy: 0 };
  let b2 = { x: center.x - 0.10*scale, y: center.y + 0.15*scale, vx: 160, vy: 0 };

  // history for delay (shared)
  const AHistory = []; // {t,x,y,vx,vy,ax,ay}

  // trails
  const trailA  = [];
  const trailB1 = [];
  const trailB2 = [];

  // distance series
  const distSeries = []; // {time,d1,d2}

  // utils
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function norm(x,y){ const r=Math.hypot(x,y) || 1e-9; return {x:x/r, y:y/r}; }

  function readNum(el, fallback){
    const v = Number(el.value);
    return Number.isFinite(v) ? v : fallback;
  }

  // A guide trajectories
  function guidePos(kind, tt){
    if(kind === 'circle'){
      const w = 1.0, r = 0.9;
      return { x: center.x + scale*r*Math.cos(w*tt), y: center.y + scale*r*Math.sin(w*tt) };
    }
    if(kind === 'ellipse'){
      const w = 0.9, rx = 1.0, ry = 0.55;
      return { x: center.x + scale*rx*Math.cos(w*tt), y: center.y + scale*ry*Math.sin(w*tt) };
    }
    if(kind === 'lissajous'){
      const ax = 3, by = 2, delta = 0.6;
      return { x: center.x + scale*0.95*Math.sin(ax*tt + delta), y: center.y + scale*0.95*Math.sin(by*tt) };
    }
    if(kind === 'line'){
      const w = 0.7;
      const s = Math.sin(w*tt);
      const ang = 0.3, len = 1.0;
      return { x: center.x + scale*len*s*Math.cos(ang), y: center.y + scale*len*s*Math.sin(ang) };
    }
    if(kind === 'randomwalk'){
      return { x: rwStateA.x, y: rwStateA.y };
    }
    return { x: center.x, y: center.y };
  }

  function stepRandomWalkA(dt){
    if(trajAEl.value !== 'randomwalk') return;
    const strength = Math.max(0, readNum(rwEl, 2.5));
    const damping = 0.88;
    const maxV = 420;

    const ax = (Math.random()*2-1) * strength * 60;
    const ay = (Math.random()*2-1) * strength * 60;

    rwStateA.vx = damping*rwStateA.vx + ax*dt;
    rwStateA.vy = damping*rwStateA.vy + ay*dt;

    const sp = Math.hypot(rwStateA.vx, rwStateA.vy);
    if(sp > maxV){ rwStateA.vx *= maxV/sp; rwStateA.vy *= maxV/sp; }

    rwStateA.x += rwStateA.vx*dt;
    rwStateA.y += rwStateA.vy*dt;

    const pad = 24;
    if(rwStateA.x < pad){ rwStateA.x = pad; rwStateA.vx *= -0.8; }
    if(rwStateA.x > W-pad){ rwStateA.x = W-pad; rwStateA.vx *= -0.8; }
    if(rwStateA.y < pad){ rwStateA.y = pad; rwStateA.vy *= -0.8; }
    if(rwStateA.y > H-pad){ rwStateA.y = H-pad; rwStateA.vy *= -0.8; }
  }

  function pushAHistory(sample){
    AHistory.push(sample);
    // keep enough for max delay (<=1.5s typical) but allow user input; keep a safe cap
    while(AHistory.length > 12000) AHistory.shift();
  }

  function getDelayedA(tNow, delay){
    const target = tNow - delay;
    if(AHistory.length === 0) return null;
    if(target <= AHistory[0].t) return AHistory[0];
    if(target >= AHistory[AHistory.length-1].t) return AHistory[AHistory.length-1];

    // binary search: last entry with t <= target
    let lo = 0, hi = AHistory.length - 1;
    while(lo + 1 < hi){
      const mid = (lo + hi) >> 1;
      if(AHistory[mid].t <= target) lo = mid;
      else hi = mid;
    }
    return AHistory[lo];
  }

  function updatePursuer(B, params, dt){
    const { rule, speed, baseTurn, mass, delay } = params;
    const A_del = getDelayedA(t, delay) || AState;

    // LOS from B to delayed A
    const LOS = { x: A_del.x - B.x, y: A_del.y - B.y };
    const uLOS = norm(LOS.x, LOS.y);

    // current velocity direction
    const spB = Math.hypot(B.vx, B.vy) || 1e-9;
    const uV = { x: B.vx/spB, y: B.vy/spB };

    let uDes = uLOS;

    if(rule === 'lead'){
      // constant lead time; keep it fixed for comparability
      const leadTime = 0.45; // s
      const fx = A_del.x + A_del.vx*leadTime + 0.5*A_del.ax*leadTime*leadTime;
      const fy = A_del.y + A_del.vy*leadTime + 0.5*A_del.ay*leadTime*leadTime;
      uDes = norm(fx - B.x, fy - B.y);
    }

    if(rule === 'pn'){
      // simplified PN-like steering: push uV toward LOS with gain on sin(angle)
      const cross = uV.x*uLOS.y - uV.y*uLOS.x; // ~sin(angle error)
      const perp  = { x: -uV.y, y: uV.x };
      const k = 1.1;
      const steer = { x: uV.x + k*cross*perp.x, y: uV.y + k*cross*perp.y };
      uDes = norm(steer.x, steer.y);
    }

    // inertia: turnRate = baseTurn / mass
    const turnRate = (mass > 0) ? (baseTurn / mass) : baseTurn;

    // rotate uV toward uDes with limited angular speed
    const ang0 = Math.atan2(uV.y, uV.x);
    const ang1 = Math.atan2(uDes.y, uDes.x);

    let dAng = ang1 - ang0;
    while(dAng >  Math.PI) dAng -= 2*Math.PI;
    while(dAng < -Math.PI) dAng += 2*Math.PI;

    const maxStep = turnRate * dt;
    dAng = clamp(dAng, -maxStep, maxStep);
    const angNew = ang0 + dAng;

    B.vx = speed * Math.cos(angNew);
    B.vy = speed * Math.sin(angNew);

    B.x += B.vx * dt;
    B.y += B.vy * dt;

    // keep inside (soft bounce)
    const pad = 24;
    if(B.x < pad){ B.x = pad; B.vx *= -0.6; }
    if(B.x > W-pad){ B.x = W-pad; B.vx *= -0.6; }
    if(B.y < pad){ B.y = pad; B.vy *= -0.6; }
    if(B.y > H-pad){ B.y = H-pad; B.vy *= -0.6; }
  }

  function drawTrail(tr, color){
    if(tr.length < 2) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<tr.length;i++){
      const p = tr[i];
      if(i===0) ctx.moveTo(p.x,p.y);
      else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
  }

  function drawPoint(P, color, label){
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(P.x,P.y,7,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.font = '14px system-ui';
    ctx.fillText(label, P.x+10, P.y-10);
  }

  function drawScene(A, B1, B2, d1, d2){
    ctx.clearRect(0,0,W,H);

    // grid
    ctx.strokeStyle = '#f0f0f0';
    ctx.lineWidth = 1;
    for(let x=0;x<=W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    // trails
    const maxTrail = Math.max(0, Math.floor(readNum(trailLenEl, 220)));
    while(trailA.length  > maxTrail) trailA.shift();
    while(trailB1.length > maxTrail) trailB1.shift();
    while(trailB2.length > maxTrail) trailB2.shift();

    drawTrail(trailA,  '#1f77b4'); // A
    drawTrail(trailB1, '#ff7f0e'); // B1
    drawTrail(trailB2, '#9467bd'); // B2

    // connecting lines
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#222';
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B1.x,B1.y); ctx.stroke();
    ctx.strokeStyle = '#555';
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B2.x,B2.y); ctx.stroke();

    // capture radius around A
    const capR = Math.max(0, readNum(captureREl, 0.5));
    if(capR > 0){
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(A.x, A.y, capR, 0, Math.PI*2);
      ctx.stroke();
    }

    // points
    drawPoint(A,  '#1f77b4', 'A');
    drawPoint(B1, '#ff7f0e', 'B1');
    drawPoint(B2, '#9467bd', 'B2');

    // labels
    ctx.fillStyle = '#111';
    ctx.font = '16px system-ui';
    ctx.fillText(`d1=${d1.toFixed(3)} px   d2=${d2.toFixed(3)} px`, 16, 28);

    ctx.font = '12px system-ui';
    const msg = capturedBy ? `${capturedBy} 捕获（自动暂停）` : (running ? '' : '暂停');
    ctx.fillText(msg, 16, 46);
  }

  function drawPlot(){
    pctx.clearRect(0,0,PW,PH);

    // plot frame
    pctx.strokeStyle = '#ddd';
    pctx.lineWidth = 1;
    pctx.strokeRect(52, 18, PW-70, PH-46);

    const windowSec = clamp(readNum(plotWinEl, 12), 2, 60);
    const tMax = t;
    const tMin = Math.max(0, tMax - windowSec);

    const visible = distSeries.filter(p => p.time >= tMin && p.time <= tMax);
    if(visible.length < 2){
      pctx.fillStyle = '#666';
      pctx.fillText('数据不足', 60, 40);
      return;
    }

    // min/max across both curves
    let dMin = Infinity, dMax = -Infinity;
    for(const p of visible){
      dMin = Math.min(dMin, p.d1, p.d2);
      dMax = Math.max(dMax, p.d1, p.d2);
    }
    const pad = (dMax - dMin) * 0.15 + 1e-6;
    dMin -= pad; dMax += pad;

    const x0 = 52, y0 = 18, ww = PW-70, hh = PH-46;
    function X(tt){ return x0 + ww*(tt - tMin)/(tMax - tMin); }
    function Y(dd){ return y0 + hh*(1 - (dd - dMin)/(dMax - dMin)); }

    // grid lines
    pctx.strokeStyle = '#f0f0f0';
    for(let i=1;i<=5;i++){
      const yy = y0 + hh*i/6;
      pctx.beginPath(); pctx.moveTo(x0,yy); pctx.lineTo(x0+ww,yy); pctx.stroke();
    }

    // curve1 (orange)
    pctx.strokeStyle = '#ff7f0e';
    pctx.lineWidth = 2;
    pctx.beginPath();
    visible.forEach((p, i) => {
      const xx = X(p.time), yy = Y(p.d1);
      if(i===0) pctx.moveTo(xx,yy); else pctx.lineTo(xx,yy);
    });
    pctx.stroke();

    // curve2 (purple)
    pctx.strokeStyle = '#9467bd';
    pctx.lineWidth = 2;
    pctx.beginPath();
    visible.forEach((p, i) => {
      const xx = X(p.time), yy = Y(p.d2);
      if(i===0) pctx.moveTo(xx,yy); else pctx.lineTo(xx,yy);
    });
    pctx.stroke();

    // title/legend
    pctx.fillStyle = '#111';
    pctx.font = '12px system-ui';
    pctx.fillText(`窗口: ${windowSec.toFixed(1)} s`, 60, 14);
    pctx.fillText(`d范围: ${dMin.toFixed(2)} ~ ${dMax.toFixed(2)} px`, 150, 14);

    pctx.fillStyle = '#ff7f0e';
    pctx.fillText('d1(t) - B1', PW-180, 14);
    pctx.fillStyle = '#9467bd';
    pctx.fillText('d2(t) - B2', PW-95, 14);

    // ticks
    pctx.fillStyle = '#555';
    pctx.font = '11px system-ui';
    for(let i=0;i<=4;i++){
      const dd = dMax - (dMax-dMin)*i/4;
      const yy = Y(dd);
      pctx.fillText(dd.toFixed(2), 6, yy+4);
    }
    for(let i=0;i<=4;i++){
      const tt = tMin + (tMax-tMin)*i/4;
      const xx = X(tt);
      pctx.fillText(tt.toFixed(1), xx-10, PH-10);
    }
  }

  function resetAll(){
    t = 0;
    last = performance.now();
    running = true;
    capturedBy = "";
    toggleBtn.textContent = '暂停';

    trailA.length = 0;
    trailB1.length = 0;
    trailB2.length = 0;
    distSeries.length = 0;
    AHistory.length = 0;

    rwStateA = { x: center.x + 0.2*scale, y: center.y, vx: 0, vy: 0 };

    // init A at guide(0)
    const g = guidePos(trajAEl.value, 0);
    AState = { x: g.x, y: g.y, vx: 0, vy: 0, ax: 0, ay: 0 };

    // init B1/B2
    const s1 = readNum(b1SpeedEl, 170);
    const s2 = readNum(b2SpeedEl, 170);
    b1 = { x: center.x - 0.25*scale, y: center.y, vx: s1, vy: 0 };
    b2 = { x: center.x - 0.10*scale, y: center.y + 0.15*scale, vx: s2, vy: 0 };

    pushAHistory({ t, x:AState.x, y:AState.y, vx:0, vy:0, ax:0, ay:0 });
  }

  function tick(now){
    const dtReal = (now - last)/1000;
    last = now;

    const speedMul = Math.max(0.1, readNum(speedMulEl, 1.2));
    const dtMax = clamp(readNum(dtMaxEl, 0.05), 0.01, 0.2);
    const dt = clamp(dtReal, 0, dtMax) * speedMul;

    if(running){
      t += dt;

      // update A guide/randomwalk
      stepRandomWalkA(dt);
      const guide = guidePos(trajAEl.value, t);

      // move A toward guide with limited speed aSpeed
      const aSpeed = Math.max(0, readNum(aSpeedEl, 160));
      const dx = guide.x - AState.x;
      const dy = guide.y - AState.y;
      const dist = Math.hypot(dx,dy) || 1e-9;
      const step = Math.min(dist, aSpeed * dt);

      const vxNew = (dx/dist) * (step/dt);
      const vyNew = (dy/dist) * (step/dt);

      const axNew = (vxNew - AState.vx) / (dt || 1e-6);
      const ayNew = (vyNew - AState.vy) / (dt || 1e-6);

      AState.x += (dx/dist) * step;
      AState.y += (dy/dist) * step;
      AState.ax = axNew; AState.ay = ayNew;
      AState.vx = vxNew; AState.vy = vyNew;

      // push history for delay
      pushAHistory({ t, x:AState.x, y:AState.y, vx:AState.vx, vy:AState.vy, ax:AState.ax, ay:AState.ay });

      // update B1/B2
      updatePursuer(b1, {
        rule: b1RuleEl.value,
        speed: Math.max(0, readNum(b1SpeedEl, 170)),
        baseTurn: Math.max(0, readNum(b1TurnEl, 4)),
        mass: Math.max(0.1, readNum(b1MassEl, 2.0)),
        delay: Math.max(0, readNum(b1DelayEl, 0.3))
      }, dt);

      updatePursuer(b2, {
        rule: b2RuleEl.value,
        speed: Math.max(0, readNum(b2SpeedEl, 170)),
        baseTurn: Math.max(0, readNum(b2TurnEl, 4)),
        mass: Math.max(0.1, readNum(b2MassEl, 3.5)),
        delay: Math.max(0, readNum(b2DelayEl, 0.6))
      }, dt);

      const A  = { x:AState.x, y:AState.y };
      const B1 = { x:b1.x, y:b1.y };
      const B2 = { x:b2.x, y:b2.y };

      const d1 = Math.hypot(A.x - B1.x, A.y - B1.y);
      const d2 = Math.hypot(A.x - B2.x, A.y - B2.y);

      // capture check
      const capR = Math.max(0, readNum(captureREl, 0.5));
      if(d1 <= capR){ running = false; capturedBy = "B1"; toggleBtn.textContent = '运行'; }
      else if(d2 <= capR){ running = false; capturedBy = "B2"; toggleBtn.textContent = '运行'; }

      // store series
      distSeries.push({ time:t, d1, d2 });
      while(distSeries.length > 20000) distSeries.shift();

      // store trails
      trailA.push({ x:A.x,  y:A.y  });
      trailB1.push({x:B1.x, y:B1.y });
      trailB2.push({x:B2.x, y:B2.y });

      drawScene(A, B1, B2, d1, d2);
      drawPlot();
    } else {
      // still render
      const A  = { x:AState.x, y:AState.y };
      const B1 = { x:b1.x, y:b1.y };
      const B2 = { x:b2.x, y:b2.y };
      const d1 = Math.hypot(A.x - B1.x, A.y - B1.y);
      const d2 = Math.hypot(A.x - B2.x, A.y - B2.y);
      drawScene(A, B1, B2, d1, d2);
      drawPlot();
    }

    requestAnimationFrame(tick);
  }

  toggleBtn.addEventListener('click', () => {
    running = !running;
    toggleBtn.textContent = running ? '暂停' : '运行';
  });

  resetBtn.addEventListener('click', () => resetAll());

  resetAll();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
